package gpse.example.domain.email;

import gpse.example.domain.exceptions.MessageGenerationException;
import gpse.example.domain.users.User;
import org.springframework.mail.javamail.MimeMessageHelper;

import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import javax.persistence.*;
import java.lang.reflect.InvocationTargetException;
import java.time.LocalDateTime;

/**
 * Class representing messages that are send via email and are stored in database.
 */
@Entity
public class Message {

    private static final String UTF_EIGHT = "utf-8";
    private static final String SYSTEM = "System";
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column
    private long messageID;

    @Column
    private String subject;

    @Lob
    private String text;

    @Column
    private LocalDateTime timeStamp;

    @Column
    private String recievingUserMail;

    @ManyToOne
    @JoinColumn
    private User sendingUser;

    @Column
    private Category category;

    @Column
    private boolean watched;

    public Message() {
        timeStamp = LocalDateTime.now();
    }

    /**
     * generates the html Formatted mailmessage.
     * @param message MimeMessage generated by mailsender
     * @return the Filled mailMessage
     * @throws MessagingException thrown by internet address.parse
     * @throws MessageGenerationException thrown if relevant data is missing
     */
    public MimeMessage generateHtmlMessage(final MimeMessage message) throws MessagingException,
            MessageGenerationException {

        message.setSubject(subject, UTF_EIGHT);

        final MimeMessageHelper helper = new MimeMessageHelper(message, true, UTF_EIGHT);

        if (sendingUser == null) {
            helper.setFrom(SYSTEM);
        } else {
            helper.setFrom(sendingUser.getEmail());
        }

        if (recievingUserMail == null || subject == null || text == null) {
            throw new MessageGenerationException(this.messageID);
        }

        helper.setTo(InternetAddress.parse(recievingUserMail));
        message.setContent(text, "text/html");
        return message;
    }

    /**
     * setting up subject and text by template and data.
     * @param template the template
     * @param dataContainer the data needed to fill placeholder
     * @throws InvocationTargetException thrown by filled template
     */
    public void setupByTemplate(final EmailTemplate template, final TemplateDataContainer dataContainer)
            throws InvocationTargetException {
        this.subject = template.getSubject();
        this.text = template.filledTemplate(dataContainer);

    }


    public long getMessageID() {
        return messageID;
    }

    public void setMessageID(final long messageID) {
        this.messageID = messageID;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(final String subject) {
        this.subject = subject;
    }

    public String getText() {
        return text;
    }

    public void setText(final String text) {
        this.text = text;
    }

    public LocalDateTime getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(final LocalDateTime timeStamp) {
        this.timeStamp = timeStamp;
    }

    public String getRecievingUserMail() {
        return recievingUserMail;
    }

    public void setRecievingUserMail(final String email) {
        this.recievingUserMail = email;
    }

    public User getSendingUser() {
        return sendingUser;
    }

    public void setSendingUser(final User sendingUser) {
        this.sendingUser = sendingUser;
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(final Category category) {
        this.category = category;
    }

    public boolean isWatched() {
        return watched;
    }

    public void setWatched(final boolean watched) {
        this.watched = watched;
    }
}
